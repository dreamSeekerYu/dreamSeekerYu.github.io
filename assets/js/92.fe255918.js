(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{449:function(s,t,a){"use strict";a.r(t);var n=a(46),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"函数柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数柯里化"}},[s._v("#")]),s._v(" 函数柯里化")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function curry(fn) {\n  return function curried(...args) {\n    // fn.length 返回需要科里化的方法的 arguments 的长度,\n    // 如果不到这个长度，则说明需要继续接受参数，\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function (...args2) {\n        return curried.apply(this, args.concat(args2));\n      };\n    }\n  };\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function add(n) {\n  let s = n;\n\n  return function fun(m) {\n    if (!m) return s;\n    s += m;\n    return fun;\n  };\n}\n\nconsole.log(add(1)(2)(3)(4)()); //10\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("h2",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[s._v("#")]),s._v(" 原型链")]),s._v(" "),a("h5",{attrs:{id:"原型链的基本构想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链的基本构想"}},[s._v("#")]),s._v(" 原型链的基本构想")]),s._v(" "),a("p",[s._v("要想掌握js中继承的几种实现方法，就必须了解原型链")]),s._v(" "),a("ol",[a("li",[s._v("每个构造函数都有一个原型对象prototype，通过prototype对象我们可以为构造函数的实例动态的添加属性和方法。由于这个特性，我们可以看到在一些框架实现中没有使用class去声明类而是使用构造函数，比如说Vue 2.x， 这是因为构造函数的prototype具有更好的扩展性，这种编程思维是值得我们去学习的")]),s._v(" "),a("li",[s._v("每个peototype对象都有一个constructor属性，指向prototype对象的构造函数，通过constructor属性我们可以判断一个对象的是函数还是数组，还是其他的内置对象，")]),s._v(" "),a("li",[s._v("构造函数的实例对象有一个内置的指针__proto__,这个指针指向构造函数的prototype对象")]),s._v(" "),a("li",[s._v("那么我们现在可以去思考原型链式怎么串起来的了，如果当前的构造函数的Prototype属性是也是另一构造函数的实例，那么它的内置指针__proto__又会指向另一个构造函数的prototype对象,这就形成了一条原型链。")])]),s._v(" "),a("h5",{attrs:{id:"二、原型链的搜索机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、原型链的搜索机制"}},[s._v("#")]),s._v(" 二、原型链的搜索机制")]),s._v(" "),a("p",[s._v("在读取实例对象上的属性时，首先会在实例上搜索这属性，如果没有找到，就会顺着原型链继续想下搜索，一直到原型链的末端null")]),s._v(" "),a("h5",{attrs:{id:"三、-原型链的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、-原型链的问题"}},[s._v("#")]),s._v(" 三、 原型链的问题")]),s._v(" "),a("p",[s._v("原型中如果包含引用值，就会在原型中共享，这是不合理的。\n在面试过程是不是经常会遇到一个问题，Vue总的data选项为什么只能是函数，不能使用对象呢？这个问题根本原因就在这了。\nVue根实例中data选项是可以使用对象表示的，这英文，根实例时全局唯一的，不会有其他的实例和根实例公享这个对象了，然而在组件实例并不能保证全局唯一性，如果使用对象作为data选项，会导致多个组件实例公用一个对象，这会造成数据污染。 （可以稍微看看，扯得有点远了）")]),s._v(" "),a("h5",{attrs:{id:"四、-继承的几种实现方式-推荐-组合继承和-class-继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、-继承的几种实现方式-推荐-组合继承和-class-继承"}},[s._v("#")]),s._v(" 四、 继承的几种实现方式  (推荐 组合继承和 class 继承)")]),s._v(" "),a("blockquote",[a("ol",[a("li",[s._v("原型继承： 将父类构造函数的原型对象拷贝至子类构造函数的原型上")])])]),s._v(" "),a("p",[s._v("这样做的弊端是子类只能继承原型上的实例属性和实例方法， 不能继承构造函数中的静态属性和方法")]),s._v(" "),a("blockquote",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("原型链继承: 将父类构造函数的实例设置为子类构造函数的原型对象")])])]),s._v(" "),a("p",[s._v("不方便传参,同样存在着子类只能继承原型上的实例属性和实例方法， 不能继承构造函数中的静态属性和方法")]),s._v(" "),a("blockquote",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("借用构造函数实现继承: 使用call，apply等改变子类的this指向")])])]),s._v(" "),a("p",[s._v("可一个继承父类构造函数中的静态属性和方法，但是不能继承父类构造函数上的属性和方法，好处是好传参")]),s._v(" "),a("blockquote",[a("ol",{attrs:{start:"4"}},[a("li",[s._v("组合继承: 借用构造函数继承 + 原型链继承")])])]),s._v(" "),a("p",[s._v("既方便传参，并且既能继承构造函数内部的方法，又能继承原型上的方法和属性")]),s._v(" "),a("blockquote",[a("ol",{attrs:{start:"5"}},[a("li",[s._v("class类继承：构造函数方式 + 原型链继承")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);